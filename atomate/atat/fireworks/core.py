# coding: utf-8

from __future__ import absolute_import, division, print_function, \
    unicode_literals

try:
    from math import gcd
except ImportError:
    from fractions import gcd

import warnings
from fireworks import Firework
from fireworks import ScriptTask
from pymatgen import Structure
#from pymatgen.analysis.structure_matcher import StructureMatcher, OccupancyComparator
from pymatgen.transformations.standard_transformations import OrderDisorderedStructureTransformation
from fractions import Fraction

class McsqsFW(Firework):

    def __init__(self, disordered_struct,
                 name="mcsqs",
                 size=None,
                 clusters=None,
                 user_input_settings=None,
                 occu_tol=8,
                 ncores=1,
                 **kwargs):
        """
        Find a best SQS approximation for a given disordered
        structure using the mcsqs code from the ATAT library.

        :param disordered_struct: disordered structure
        :param name: name of the Firework
        :param size: number of atoms in the output supercell,
        if None will choose the smallest possible supercell
        :param clusters: dict of cluster sizes, e.g.
        {2: 1.5, 3: 1.0} to search for pairs of atoms
        within a radius of 1.5 Å and triplets of atoms
        within a radius of 1.0 Å, if None will try to
        pick sensible defaults, the value of mcsqs is
        that this should converge rapidly with number of
        clusters (aim for around a dozen)
        :param user_input_settings: dict of additional keyword
        value pairs to pass to mcsqs, such as Monte Carlo
        temperature, no validation is performed on this dict
        :param: occu_tol (int): As in pymatgen's
        EnumerateStructureTransformation.
        Will round occupancies to the nearest rational number,
        with the maximum denominator equal to occu_tol.
        :param: ncores (int): number of instances of mcsqs
        to run (mcsqs is not parallelized, these are run
        independently of each other)
        :param kwargs: Other kwargs that are passed to Firework.__init__.
        """

        if disordered_struct.is_ordered:
            raise ValueError("You must input a disordered structure.")

        if occu_tol:
            # from pymatgen's EnumerateStructureTransformation
            species = [dict(d) for d in disordered_struct.species_and_occu]
            for sp in species:
                for k, v in sp.items():
                    sp[k] = float(Fraction(v).limit_denominator(occu_tol))
            disordered_struct = Structure(disordered_struct.lattice, species,
                                          disordered_struct.frac_coords)

        if size is None:
            size = self._determine_min_cell(disordered_struct)

        if clusters is None:
            # TODO: make cluster determination a bit smarter!
            lattice_param = min(disordered_struct.lattice.abc)
            clusters = {
                2: lattice_param*1.5,
                3: lattice_param*1.5,
                4: lattice_param
            }
        else:
            for cluster in clusters.keys():
                if cluster not in [2, 3, 4, 5, 6]:
                    raise ValueError("Mcsqs only supports clusters of 2-6 atoms.")

        disordered_struct.to('mcsqs', filename='rndstr.in')

        cluster_str = " ".join(["{}={}".format(k, v) for k, v in clusters.items()])
        generate_cluster_cmd = "mcsqs {}".format(cluster_str)

        if user_input_settings:
            user_input_settings_str = " ".join(["{}={}".format(k, v) for k, v
                                            in user_input_settings.items()])
        else:
            user_input_settings_str = ""

        # TODO: this will only work in bash shell, how to enforce shell with FW?
        # TODO: retrieve walltime, retrieve ncores from FW env
        # TODO: write FW.json with input args

        # mcsqs is not parallelised, and is not expected to finish within the walltime
        # it's a Monte Carlo process that can run indefinitely, so we use timeout
        # to ensure the command finishes
        run_mcsqs_cmd = """
for (( id=0 ; id<{} ; id ++ ))
do
    timeout {}s mcsqs -n {} {}  -ip=$id &
done
""".format(ncores, 30, size, user_input_settings_str)

        # findbestsqs seems to be auto-generated by mcsqs,
        # but there's also an alternative to this command within mcsqs itself
        get_bestsqs_cmd = "./findbestsqs"

        write_version_cmd = "mcsqs -v | head > mcsqs_version.txt"

        t = [
            ScriptTask(script=[
                generate_cluster_cmd,
                run_mcsqs_cmd,
                get_bestsqs_cmd,
                write_version_cmd
            ], clusters=clusters, user_input_settings=user_input_settings)
        ]

        super(McsqsFW, self).__init__(t, name=name, **kwargs)

    @staticmethod
    def _determine_min_cell(disordered_struct):
        """
        Determine the minimum cell size required for an
        ordered structure.
        """

        trans = OrderDisorderedStructureTransformation()
        ordered_struct = trans.apply_transformation(disordered_struct,
                                                    return_ranked_list=False)
        return len(ordered_struct)

# TODO: add a duplicate checker
# when we want to create a firework, check the database first
# if bestsqs present, use that, if not run McsqsFW()

# to do this, will query database for all structures with same space group
# then for every disordered structure in returned query, run structurematcher
# if we get a match, use the bestsqs from that doc
# sm = StructureMatcher(comparator=OccupancyComparator())